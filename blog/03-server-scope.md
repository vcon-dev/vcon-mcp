# What the vCon MCP Server Can Do

The vCon MCP Server provides over 27 tools that let AI assistants work with conversation data. This post gives you a complete overview of what the server can do, organized by category.

## Core Operations: Managing Conversations

The server can create, read, update, and delete conversation records. These are the basic operations you need for managing any conversation data.

### Creating Conversations

You can create new conversation records in several ways:

**Create from scratch** - Provide all the conversation data in vCon format, including participants, dialog content, analysis results, and attachments. The server validates everything to ensure it follows the IETF vCon standard before storing it.

**Create from templates** - Use predefined templates for common conversation types. The server includes templates for phone calls, chat conversations, email threads, and video meetings. Templates set up the basic structure, and you add the specific details.

When you create a conversation, the server automatically generates a unique identifier if you do not provide one. It also records when the conversation was created and can track when it was last updated.

### Reading Conversations

You can retrieve conversations by their unique identifier. The server returns the complete conversation record, including all participants, dialog content, analysis results, and attachments.

You can also request only specific parts of a conversation. For example, you might want just the participant information, or just the analysis results. This is useful when you do not need the entire conversation and want to reduce the amount of data transferred.

The server also provides resources, which are URI-based ways to access conversation data. This lets you access specific parts of conversations directly without going through the full tool interface.

### Updating Conversations

You can update the metadata of conversations, such as the subject line or custom extensions. The server supports different update strategies. You can replace existing values, merge new values with existing ones, or append to existing arrays.

Updates are validated to ensure the conversation still follows the vCon standard after changes. This prevents accidental corruption of your data.

### Deleting Conversations

You can delete conversations and all their related data. The server requires explicit confirmation to prevent accidental deletions. When you delete a conversation, it removes all associated participants, dialog entries, analysis results, and attachments.

## Component Management: Adding Parts to Conversations

A conversation record can have several types of components. You can add or update these components without recreating the entire conversation.

### Dialog Entries

Dialog entries are the actual conversation content. This might be a phone call recording, a text chat, an email message, or a video call segment. Each dialog entry includes information about when it occurred, who participated, and the content itself.

The server supports different types of dialog:
- Recordings of audio or video
- Text-based conversations
- Transfers where a call was moved between agents
- Incomplete conversations where the recording was cut off

You can add multiple dialog entries to a single conversation, which is useful for conversations that happened across multiple sessions or channels.

### Analysis Results

Analysis results are insights generated by AI or other processing tools. Examples include transcripts of audio recordings, sentiment analysis, summaries, topic extraction, and named entity recognition.

Each analysis entry includes information about what tool created it, what version or model was used, and when it was created. This makes it possible to track how analysis results were generated and compare results from different tools.

The server can store analysis results in different formats. Some might be plain text, while others might be structured JSON data. The server handles both types correctly.

### Attachments

Attachments are files or documents related to the conversation. This might be an invoice discussed during a call, a screenshot shared during a chat, or a contract sent via email.

Attachments can be stored in different ways. They can be embedded directly in the conversation record, or they can be referenced by URL if stored elsewhere. The server tracks what type of file each attachment is and can link attachments to specific dialog entries or participants.

Tags are a special type of attachment used for organization, which we will cover in more detail later.

### Participant Management

Participants, called parties in the vCon standard, are the people or entities involved in a conversation. Each party has information like name, email address, phone number, role, and organization.

The server lets you add, update, and manage participants. You can link dialog entries and attachments to specific participants, making it easy to see what each person said or contributed.

## Search Capabilities: Finding What You Need

The server provides four different ways to search conversations. Each method works better for different types of queries.

### Basic Filter Search

Basic filter search lets you find conversations by metadata like subject line, participant names, email addresses, phone numbers, or date ranges. This is the fastest search method and works well when you know specific details about what you are looking for.

For example, you could search for all conversations from last week where a specific customer participated. The search returns complete conversation records that match your criteria.

### Keyword Search

Keyword search looks for specific words or phrases within the conversation content. It searches through subject lines, dialog text, analysis results, and participant information. This is useful when you remember a specific word or phrase but do not remember other details about the conversation.

The search uses full-text indexing, which makes it fast even with large numbers of conversations. It also handles minor typos and variations in spelling. Results show snippets of where the keywords were found, making it easy to see the relevant parts.

You can combine keyword search with filters like date ranges or tags to narrow down results.

### Semantic Search

Semantic search finds conversations by meaning rather than exact words. It uses AI embeddings to understand what conversations are about and can find related content even when the exact words are different.

For example, if you search for "customer frustration," semantic search might find conversations where customers were "upset," "angry," "disappointed," or "unhappy," even if those exact words were not used. This makes semantic search useful when you are looking for concepts rather than specific phrases.

Semantic search requires that conversations have been processed to generate embeddings. The server can generate these embeddings when conversations are created or updated, or you can process existing conversations in batch.

### Hybrid Search

Hybrid search combines keyword search and semantic search. It uses both methods and combines the results, giving you the benefits of both approaches. Keyword search finds exact matches, while semantic search finds conceptually related content.

You can control how much weight each method has in the results. For example, you might want exact keyword matches to rank higher than semantic matches, or vice versa.

## Tag System: Organizing Conversations

Tags are key-value pairs that you can attach to conversations for organization and filtering. Tags are flexible. You can use them however makes sense for your workflow.

### Adding and Managing Tags

You can add tags individually or in groups. Tags can have string, number, or boolean values. For example, you might tag conversations with department names, priority levels, resolution status, or customer IDs.

The server provides tools to add, update, get, and remove tags. You can also bulk update tags across multiple conversations, which is useful when you need to reorganize or reclassify conversations.

### Searching by Tags

All search methods support filtering by tags. You can require conversations to have specific tags, or you can search for conversations that have any of several tags. This makes it easy to narrow down results to the conversations you care about.

For example, you might search for high-priority sales conversations from last month. The tag system makes this type of query simple and fast.

### Tag Analytics

The server can analyze your tag usage to show you what tags are used most often, what values are most common, and how tags are distributed across your conversations. This helps you understand how conversations are organized and can guide decisions about tag structure.

## Database Analytics: Understanding Your Data

The server provides comprehensive analytics about your conversation database. These tools help you understand what you have, how it is growing, and how it is structured.

### Overall Analytics

You can get analytics about database size, growth trends, content distribution, and health metrics. This includes information like total number of conversations, how many have been added over time, what types of content are stored, and how the database is performing.

### Growth Analytics

The server can analyze growth patterns over time, showing monthly trends and projections. This helps you understand if your conversation data is growing steadily, if there are seasonal patterns, or if growth is accelerating.

### Content Analytics

Content analytics show what types of conversations you have, what types of dialog entries are stored, what analysis has been performed, and how participants are distributed. This helps you understand the composition of your conversation data.

### Attachment Analytics

Attachment analytics show what types of files are stored, how much storage they use, and how they are distributed across conversations. This helps you understand storage usage and plan for capacity.

### Health Metrics

Health metrics show database performance indicators like query speed, index usage, and cache hit rates. This helps you identify performance issues and optimize your database configuration.

## Database Tools: Inspection and Optimization

The server includes tools for inspecting and optimizing your database. These are useful for understanding your database structure and ensuring it performs well.

### Database Shape

You can inspect the database structure to see what tables exist, what indexes are defined, how large tables are, and how tables relate to each other. This is useful for understanding the database schema and debugging issues.

### Database Statistics

You can get statistics about database usage, including how often tables are accessed, how indexes are being used, and cache performance. This helps identify optimization opportunities.

### Smart Limits

For large databases, the server can recommend search limits based on database size. This prevents queries from using too much memory or taking too long. The server analyzes your database and suggests appropriate limits for different types of searches.

## Templates and Schemas: Working with Standards

The server includes support for templates and schemas that make it easier to work with the vCon standard.

### Templates

Templates provide pre-configured structures for common conversation types. Instead of building everything from scratch, you can start with a template and fill in the specifics. This reduces errors and speeds up creation of new conversation records.

The server includes templates for phone calls, chat conversations, email threads, video meetings, and custom scenarios.

### Schemas

You can request the vCon schema in different formats, including JSON Schema and TypeScript types. This is useful when building integrations or writing code that works with vCon data. The schema shows exactly what fields are required, what fields are optional, and what types of values are allowed.

### Examples

The server can provide example vCon records in different formats. Examples include minimal records, phone calls, chat conversations, emails, video meetings, and full-featured records. These examples serve as references when creating your own conversations.

## Plugin Architecture: Extending the Server

The server supports plugins that can add custom functionality. Plugins can:

- Add new tools that the assistant can use
- Add new resources for data access
- Intercept operations to add custom logic
- Implement privacy and compliance features
- Add integrations with other systems

Plugins use hooks that fire at different points in the request lifecycle. For example, a plugin might run code before a conversation is created, after it is created, before it is read, or after it is updated. This lets plugins add logging, access control, data transformation, or other functionality.

The core server focuses on standard conversation management. Plugins extend it for specific needs like compliance, privacy, or integrations.

## What is Included vs What is Not

The server is open source and includes all the features described above. However, some advanced features are available only through proprietary plugins.

### Included in Open Source

The open source version includes:
- Complete CRUD operations for conversations
- All four search modes
- Tag management
- Component management
- Database analytics
- Templates and schemas
- Basic plugin architecture

### Available Through Plugins

Advanced features available through plugins include:
- Consent management and tracking
- Privacy request handling for regulations like GDPR and CCPA
- Automatic compliance checking
- Advanced audit logging
- PII detection and masking
- Data retention enforcement
- Regulatory compliance workflows

The open source version is fully functional for general conversation data management. The proprietary plugins add features needed for regulated industries or strict compliance requirements.

## Practical Examples

Here are some practical examples of how you might use these features:

**Example 1: Customer Support Team**
A support team uses the server to store all customer calls. They tag conversations with issue types, customer IDs, and resolution status. They use semantic search to find similar past issues when helping customers. They add analysis results that include transcripts and sentiment scores.

**Example 2: Sales Team**
A sales team records all sales calls and meetings. They tag conversations with product names, deal stages, and customer segments. They use keyword search to find conversations where specific products were discussed. They generate summaries automatically and attach them as analysis results.

**Example 3: Compliance Team**
A compliance team stores all regulated communications. They use tags to track consent status and retention periods. They use database analytics to monitor data growth and ensure compliance with retention policies. They use plugins to add automatic compliance checking and audit logging.

**Example 4: Research Team**
A research team collects conversation datasets for analysis. They use the server to store conversations in a standard format that works across different tools. They use semantic search to find conversations by research themes. They export data for use in machine learning pipelines.

## Integration Points

The server integrates with several systems:

**Supabase** - The database backend. Supabase provides PostgreSQL with additional features like real-time subscriptions and REST APIs.

**Redis** - Optional caching layer. Redis can be added to dramatically speed up reads of frequently accessed conversations.

**OpenAI** - Optional for semantic search. The server can use OpenAI's API to generate embeddings for semantic search, though local models can also be used.

**AI Assistants** - Any assistant that supports MCP can connect to the server. Currently this includes Claude Desktop, with more assistants adding support over time.

## Conclusion

The vCon MCP Server provides a comprehensive set of tools for managing conversation data. It covers the basics of creating and managing conversations, advanced search capabilities, organization through tags, analytics for understanding your data, and extensibility through plugins.

The next post in this series covers the architecture of the server, explaining how it is built and why it is designed the way it is.

